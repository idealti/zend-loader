{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-loader zend-loader provides different strategies for autoloading PHP classes. File issues at https://github.com/zendframework/zend-loader/issues Documentation is at https://docs.zendframework.com/zend-loader/","title":"Home"},{"location":"#zend-loader","text":"zend-loader provides different strategies for autoloading PHP classes. File issues at https://github.com/zendframework/zend-loader/issues Documentation is at https://docs.zendframework.com/zend-loader/","title":"zend-loader"},{"location":"autoloader-factory/","text":"The AutoloaderFactory zend-loader provides multiple autoloader strategies. Zend\\Loader\\AutoloaderFactory allows you to define configuration for each strategy you wish to use and register them at once. As an example, you may have a class map for your most used classes, but want to use a PSR-0 style autoloader for 3rd party libraries. The factory uses configuration, allowing you to cache your autoloader definitions or define them centrally for your application. Quick Start The AutoloaderFactory expects an array of configuration. $config = [ 'Zend\\Loader\\ClassMapAutoloader' => [ 'application' => APPLICATION_PATH . '/.classmap.php', 'zf' => APPLICATION_PATH . '/../library/Zend/.classmap.php', ], 'Zend\\Loader\\StandardAutoloader' => [ 'namespaces' => [ 'Phly\\Mustache' => APPLICATION_PATH . '/../library/Phly/Mustache', 'Doctrine' => APPLICATION_PATH . '/../library/Doctrine', ], ], ]; Once you have your configuration in a PHP array, pass it to the AutoloaderFactory : // This example assumes that the AutoloaderFactory is itself autoloadable! use Zend\\Loader\\AutoloaderFactory; AutoloaderFactory::factory($config); The AutoloaderFactory will instantiate each autoloader with the given options, and also call its register() method to register it with the SPL autoloader. Configuration options The AutoloaderFactory expects an associative array or Traversable object. Keys should be valid autoloader class names, and the values should be the options that should be passed to the class constructor. Internally, the AutoloaderFactory checks to see if the autoloader class referenced exists. If not, it will use the StandardAutoloader to attempt to load the class via the include_path . If the class is not found, or does not implement the SplAutoloader interface, an exception will be raised. Available methods factory static factory(array|Traversable $options) : void Instantiate and register autoloaders. This method is static , and is used to instantiate autoloaders and register them with the SPL autoloader. It expects either an array or Traversable object as denoted in the options section . getRegisteredAutoloaders static getRegisteredAutoloaders() : SplAutoloader[] Retrieve a list of all autoloaders registered using the factory. This method is static , and may be used to retrieve a list of all autoloaders registered via the factory() method. It returns an array of SplAutoloader instances. getRegisteredAutoloader static getRegisteredAutoloader($class) : SplAutoloader Retrieve an autoloader by class name. This method is static , and is used to retrieve a specific autoloader by class name. If the autoloader is not registered, an exception will be thrown. unregisterAutoloaders static unregisterAutoloaders() : void Unregister all autoloaders registered via the factory. This method is static , and can be used to unregister all autoloaders that were registered via the factory. Note that this will not unregister autoloaders that were registered outside of the factory. unregisterAutoloader static unregisterAutoloader($class) : bool Unregister an autoloader registered via the factory. This method is static , and can be used to unregister an autoloader that was registered via the factory. Note that this will not unregister autoloaders that were registered outside of the factory. If the autoloader is registered via the factory, after unregistering it will return TRUE , otherwise FALSE .","title":"AutoloaderFactory"},{"location":"autoloader-factory/#the-autoloaderfactory","text":"zend-loader provides multiple autoloader strategies. Zend\\Loader\\AutoloaderFactory allows you to define configuration for each strategy you wish to use and register them at once. As an example, you may have a class map for your most used classes, but want to use a PSR-0 style autoloader for 3rd party libraries. The factory uses configuration, allowing you to cache your autoloader definitions or define them centrally for your application.","title":"The AutoloaderFactory"},{"location":"autoloader-factory/#quick-start","text":"The AutoloaderFactory expects an array of configuration. $config = [ 'Zend\\Loader\\ClassMapAutoloader' => [ 'application' => APPLICATION_PATH . '/.classmap.php', 'zf' => APPLICATION_PATH . '/../library/Zend/.classmap.php', ], 'Zend\\Loader\\StandardAutoloader' => [ 'namespaces' => [ 'Phly\\Mustache' => APPLICATION_PATH . '/../library/Phly/Mustache', 'Doctrine' => APPLICATION_PATH . '/../library/Doctrine', ], ], ]; Once you have your configuration in a PHP array, pass it to the AutoloaderFactory : // This example assumes that the AutoloaderFactory is itself autoloadable! use Zend\\Loader\\AutoloaderFactory; AutoloaderFactory::factory($config); The AutoloaderFactory will instantiate each autoloader with the given options, and also call its register() method to register it with the SPL autoloader.","title":"Quick Start"},{"location":"autoloader-factory/#configuration-options","text":"The AutoloaderFactory expects an associative array or Traversable object. Keys should be valid autoloader class names, and the values should be the options that should be passed to the class constructor. Internally, the AutoloaderFactory checks to see if the autoloader class referenced exists. If not, it will use the StandardAutoloader to attempt to load the class via the include_path . If the class is not found, or does not implement the SplAutoloader interface, an exception will be raised.","title":"Configuration options"},{"location":"autoloader-factory/#available-methods","text":"","title":"Available methods"},{"location":"class-map-autoloader/","text":"The ClassMapAutoloader The ClassMapAutoloader is designed with performance in mind. Instead of doing a filesystem lookup, it checks the class against an in-memory classmap, loading the file associated with that class on a match. This avoids unnecessary filesystem operations, and can also ensure the autoloader \"plays nice\" with opcode caches and PHP's realpath cache. The zend-loader component provides a tool for generating classmaps via bin/classmap_generator.php ; read the tool's documentation for more details. Quick Start The first step is to generate a class map file. You may run this over any directory containing source code anywhere underneath it. $ php classmap_generator.php Some/Directory/ This will create a file named Some/Directory/autoload_classmap.php , which is a PHP file returning an associative array that represents the class map. Within your code, you will now instantiate the ClassMapAutoloader , and provide it the location of the map. // This example assumes the ClassMapAutoloader is autoloadable. use Zend\\Loader\\ClassMapAutoloader; $loader = new ClassMapAutoloader(); // Register the class map: $loader->registerAutoloadMap('Some/Directory/autoload_classmap.php'); // Register with spl_autoload: $loader->register(); At this point, you may now use any classes referenced in your class map. Configuration Options The ClassMapAutoloader expects an array of options, where each option is either a filename referencing a class map, or an associative array of class name/filename pairs. As an example: // Configuration defining both a file-based class map, and an array map $config = [ __DIR__ . '/library/autoloader_classmap.php', // file-based class map [ // array class map 'Application\\Bootstrap' => __DIR__ . '/application/Bootstrap.php', 'Test\\Bootstrap' => __DIR__ . '/tests/Bootstrap.php', ], ]; Available Methods __construct __construct(array|Traversable $options = null) : void Initialize and configure the object __construct($options = null) ; $options will be passed to setOptions() . setOptions setOptions(array|Traversable $options) : void Configures the state of the autoloader, including registering class maps. $options will be passed to registerAutoloadMaps() . registerAutoloadMap registerAutoloadMap(string|array $map) : void Registers a class map with the autoloader. $map may be either a string referencing a PHP script that returns a class map, or an array defining a class map. More than one class map may be registered; each will be merged with the previous, meaning it's possible for a later class map to overwrite entries from a previously registered map. registerAutoloadMaps registerAutoloadMaps(array|Traversable $maps) : void Register multiple class maps with the autoloader, iterating over $maps and passing each value to registerAutoloadMap() . getAutoloadMap getAutoloadMap() : array Retrieves the current class map as an associative array. autoload autoload(string $class) : false|string Attempts to load the class specified. Returns a boolean false on failure, or a string indicating the class loaded on success. register register() : void Registers the autoload() method of the current instance with spl_autoload_register() . Examples Using configuration to seed ClassMapAutoloader You can use configuration to seed a ClassMapAutoloader ; values might come from a configuration file, a cache, or even a PHP array. The following is an example of a PHP array that could be used to configure the autoloader: // Configuration defining both a file-based class map, and an array map $config = [ APPLICATION_PATH . '/../library/autoloader_classmap.php', // file-based class map [ // array class map 'Application\\Bootstrap' => APPLICATION_PATH . '/Bootstrap.php', 'Test\\Bootstrap' => APPLICATION_PATH . '/../tests/Bootstrap.php', ], ]; Once you have your configuration, you can pass it either to the constructor of the ClassMapAutoloader , to its setOptions() method, or to registerAutoloadMaps() . use Zend\\Loader\\ClassMapAutoloader; /* The following are all equivalent */ // To the constructor: $loader = new ClassMapAutoloader($config); // To setOptions(): $loader = new ClassMapAutoloader(); $loader->setOptions($config); // To registerAutoloadMaps(): $loader = new ClassMapAutoloader(); $loader->registerAutoloadMaps($config);","title":"ClassMapAutoloader"},{"location":"class-map-autoloader/#the-classmapautoloader","text":"The ClassMapAutoloader is designed with performance in mind. Instead of doing a filesystem lookup, it checks the class against an in-memory classmap, loading the file associated with that class on a match. This avoids unnecessary filesystem operations, and can also ensure the autoloader \"plays nice\" with opcode caches and PHP's realpath cache. The zend-loader component provides a tool for generating classmaps via bin/classmap_generator.php ; read the tool's documentation for more details.","title":"The ClassMapAutoloader"},{"location":"class-map-autoloader/#quick-start","text":"The first step is to generate a class map file. You may run this over any directory containing source code anywhere underneath it. $ php classmap_generator.php Some/Directory/ This will create a file named Some/Directory/autoload_classmap.php , which is a PHP file returning an associative array that represents the class map. Within your code, you will now instantiate the ClassMapAutoloader , and provide it the location of the map. // This example assumes the ClassMapAutoloader is autoloadable. use Zend\\Loader\\ClassMapAutoloader; $loader = new ClassMapAutoloader(); // Register the class map: $loader->registerAutoloadMap('Some/Directory/autoload_classmap.php'); // Register with spl_autoload: $loader->register(); At this point, you may now use any classes referenced in your class map.","title":"Quick Start"},{"location":"class-map-autoloader/#configuration-options","text":"The ClassMapAutoloader expects an array of options, where each option is either a filename referencing a class map, or an associative array of class name/filename pairs. As an example: // Configuration defining both a file-based class map, and an array map $config = [ __DIR__ . '/library/autoloader_classmap.php', // file-based class map [ // array class map 'Application\\Bootstrap' => __DIR__ . '/application/Bootstrap.php', 'Test\\Bootstrap' => __DIR__ . '/tests/Bootstrap.php', ], ];","title":"Configuration Options"},{"location":"class-map-autoloader/#available-methods","text":"","title":"Available Methods"},{"location":"class-map-autoloader/#examples","text":"","title":"Examples"},{"location":"classmap-generator/","text":"The Class Map Generator utility: bin/classmap_generator.php The script bin/classmap_generator.php can be used to generate class map files for use with the ClassMapAutoloader . Internally, it consumes both the zend-console getopt functionality (for parsing command-line options) and the zend-file ClassFileLocator for recursively finding all PHP class files in a given tree. Quick Start You may run the script over any directory containing source code. By default, it will look in the current directory, and will write the script to autoloader_classmap.php in the directory you specify. $ php classmap_generator.php Some/Directory/ Configuration Options Option Description --help | -h Returns the usage message. If any other options are provided, they will be ignored. --library | -l Expects a single argument, a string specifying the library directory to parse. If this option is not specified, it will assume the current working directory. --output | -o Where to write the autoload class map file. If not provided, assumes autoload_classmap.php in the library directory. --append | -a Append to autoload file if it exists. --overwrite | -w If an autoload class map file already exists with the name as specified via the --output option, you can overwrite it by specifying this flag. Otherwise, the script will not write the class map and return a warning.","title":"ClassMap Generator"},{"location":"classmap-generator/#the-class-map-generator-utility-binclassmap95generatorphp","text":"The script bin/classmap_generator.php can be used to generate class map files for use with the ClassMapAutoloader . Internally, it consumes both the zend-console getopt functionality (for parsing command-line options) and the zend-file ClassFileLocator for recursively finding all PHP class files in a given tree.","title":"The Class Map Generator utility: bin/classmap_generator.php"},{"location":"classmap-generator/#quick-start","text":"You may run the script over any directory containing source code. By default, it will look in the current directory, and will write the script to autoloader_classmap.php in the directory you specify. $ php classmap_generator.php Some/Directory/","title":"Quick Start"},{"location":"classmap-generator/#configuration-options","text":"Option Description --help | -h Returns the usage message. If any other options are provided, they will be ignored. --library | -l Expects a single argument, a string specifying the library directory to parse. If this option is not specified, it will assume the current working directory. --output | -o Where to write the autoload class map file. If not provided, assumes autoload_classmap.php in the library directory. --append | -a Append to autoload file if it exists. --overwrite | -w If an autoload class map file already exists with the name as specified via the --output option, you can overwrite it by specifying this flag. Otherwise, the script will not write the class map and return a warning.","title":"Configuration Options"},{"location":"module-autoloader/","text":"The ModuleAutoloader Zend\\Loader\\ModuleAutoloader is a special implementation of the SplAutoloader interface, and is consumed by zend-modulemanager to autoload Module classes from different locations. Apart from being able to autoload modules from directories, the ModuleAutoloader can also autoload modules packaged as Phar archives , which allows for packaging your modules in a single file for easier distribution. Supported archive formats are: .phar , .phar.gz , .phar.bz2 , .phar.tar , .phar.tar.gz , .phar.tar.bz2 , .phar.zip , .tar , tar.gz , .tar.bz2 and .zip . It is, however, recommended to avoid compressing your packages (be it either gz, bz2 or zip compression), as it introduces additional CPU overhead to every request. Quickstart As the ModuleAutoloader is meant to be used with the ModuleManager , for examples of it's usage and how to configure it, please see the Module Autoloader Usage documentation. Configuration Options The ModuleAutoloader expects an array of options, where each option is either a path to scan for modules, or a key/value pair of explicit module paths. In the case of explicit module paths, the key is the module's name, and the value is the path to that module. $options = [ '/path/to/modules', '/path/to/other/modules', 'MyModule' => '/explicit/path/mymodule-v1.2' ]; Available Methods __construct __construct(array|Traversable $options = null) : void Initialize and configure the object; if $options are provided, they will be passed to setOptions() . setOptions setOptions(array|Traversable $options) : void Configures the state of the autoloader, registering paths to modules. $options will be passed to registerPaths() . autoload autoload(string $class) : false|string Attempts to load the specified Module class. Returns a boolean false on failure, or a string indicating the class loaded on success. register register() : void Registers the autoload() method of the current instance with spl_autoload_register() . unregister unregister() : void Unregisters the autoload() method of the current instance with spl_autoload_unregister() . registerPaths registerPaths(array|Traversable $paths) : void Register paths to modules. For an example array, please see the Configuration options section. registerPath registerPath(string $path, string $moduleName = false) : void Register a single path with the autoloader. The first parameter, $path , is expected to be a string. The second parameter, $moduleName , is expected to be a module name, which allows for registering an explicit path to that module. getPaths getPaths() : string[] Returns an array of all the paths registered.","title":"ModuleAutoloader"},{"location":"module-autoloader/#the-moduleautoloader","text":"Zend\\Loader\\ModuleAutoloader is a special implementation of the SplAutoloader interface, and is consumed by zend-modulemanager to autoload Module classes from different locations. Apart from being able to autoload modules from directories, the ModuleAutoloader can also autoload modules packaged as Phar archives , which allows for packaging your modules in a single file for easier distribution. Supported archive formats are: .phar , .phar.gz , .phar.bz2 , .phar.tar , .phar.tar.gz , .phar.tar.bz2 , .phar.zip , .tar , tar.gz , .tar.bz2 and .zip . It is, however, recommended to avoid compressing your packages (be it either gz, bz2 or zip compression), as it introduces additional CPU overhead to every request.","title":"The ModuleAutoloader"},{"location":"module-autoloader/#quickstart","text":"As the ModuleAutoloader is meant to be used with the ModuleManager , for examples of it's usage and how to configure it, please see the Module Autoloader Usage documentation.","title":"Quickstart"},{"location":"module-autoloader/#configuration-options","text":"The ModuleAutoloader expects an array of options, where each option is either a path to scan for modules, or a key/value pair of explicit module paths. In the case of explicit module paths, the key is the module's name, and the value is the path to that module. $options = [ '/path/to/modules', '/path/to/other/modules', 'MyModule' => '/explicit/path/mymodule-v1.2' ];","title":"Configuration Options"},{"location":"module-autoloader/#available-methods","text":"","title":"Available Methods"},{"location":"plugin-class-loader/","text":"The PluginClassLoader Resolving plugin names to class names is a common requirement within applications. The PluginClassLoader implements the interfaces PluginClassLocator , ShortNameLocator , and IteratorAggregate , providing a mechanism for aliasing plugin names to classnames for later retrieval. While it can act as a standalone class, it is intended that developers will extend the class to provide a per-component plugin map. This allows seeding the map with the most often-used plugins, while simultaneously allowing the end-user to overwrite existing or register new plugins. Additionally, PluginClassLoader provides the ability to statically seed all new instances of a given PluginClassLoader or one of its extensions (via Late Static Binding). If your application will always call for defining or overriding particular plugin maps on given PluginClassLoader extensions, this is a powerful capability. Quick Start Typical use cases involve instantiating a PluginClassLoader , seeding it with one or more plugin/class name associations, and then using it to retrieve the class name associated with a given plugin name. use Zend\\Http\\HeaderLoader; // Provide a global map, or override defaults: HeaderLoader::addStaticMap([ 'xrequestedfor' => 'My\\Http\\Header\\XRequestedFor', ]); // Instantiate the loader: $loader = new Zend\\Http\\HeaderLoader(); // Register a new plugin: $loader->registerPlugin('xForwardedFor', 'My\\Http\\Header\\XForwardedFor'); // Load/retrieve the associated plugin class: $class = $loader->load('xrequestedfor'); // 'My\\Http\\Header\\XRequestedFor' Case Sensitivity The PluginClassLoader is designed to do case-insensitive plugin name lookups. While the above example defines an \"xForwardedFor\" plugin name, internally, this will be stored as \"xforwardedfor\". If another plugin is registered with the same word but using a different casing structure, it will overwrite this entry. Configuration Options The constructor may take a single option, an array or Traversable object of key/value pairs corresponding to a plugin name and class name, respectively. Available Methods __construct __construct(string|array|Traversable $map = null) : void The constructor is used to instantiate and initialize the plugin class loader. If passed a string, an array, or a Traversable object, it will pass this to the registerPlugins() method in order to seed (or overwrite) the plugin class map. addStaticMap static addStaticMap(array|Traversable $map) : void Static method for globally pre-seeding the loader with a class map. It accepts either an array or Traversable object of plugin name/class name pairs. When using this method, be certain you understand the precedence in which maps will be merged; in decreasing order of preference: Manually registered plugin/class name pairs (e.g., via registerPlugin() or registerPlugins() . A map passed to the constructor. The static map. The map defined within the class itself. Also, please note that calling the method will not affect any instances already created. registerPlugin registerPlugin(string $shortName, string $className) : void Defined by the PluginClassLocator interface. Expects two string arguments, the plugin $shortName , and the class $className which it represents. registerPlugins registerPlugins(string|array|Traversable $map) : void If a string argument is provided, registerPlugins() assumes this is a class name. If the class does not exist, an exception will be thrown. If it does, it then instantiates the class and checks to see whether or not it implements Traversable , iterating it if it does. Each key/value pair obtained during iteration is then passed to registerPlugin() using the key as the plugin name and the value as the class name. unregisterPlugin unregisterPlugin(string $shortName) : void Defined by the PluginClassLocator interface; remove a plugin/class association from the plugin class map. getRegisteredPlugins getRegisteredPlugins() : array Defined by the PluginClassLocator interface; return the entire plugin class map as an array. isLoaded isLoaded(string $name) : bool Defined by the ShortNameLocator interface; determine if the given plugin has been resolved to a class name. getClassName getClassName(string $name) : string Defined by the ShortNameLocator interface; return the class name to which a plugin name resolves. load load(string $name) : string|false Defined by the ShortNameLocator interface; attempt to resolve a plugin name to a class name. If successful, returns the class name; otherwise, returns a boolean false . getIterator getIterator() : Traversable Defined by the IteratorAggregate interface; allows iteration over the plugin class map. This can come in useful for using PluginClassLoader instances to other PluginClassLoader instances in order to merge maps. Examples Using Static Maps It's often convenient to provide global overrides or additions to the maps in a PluginClassLoader instance. This can be done using the addStaticMap() method: use Zend\\Loader\\PluginClassLoader; PluginClassLoader::addStaticMap([ 'xrequestedfor' => 'My\\Http\\Header\\XRequestedFor', ]); Any later instances created will now have this map defined, allowing you to load that plugin. use Zend\\Loader\\PluginClassLoader; $loader = new PluginClassLoader(); $class = $loader->load('xrequestedfor'); // My\\Http\\Header\\XRequestedFor Creating a pre-loaded map In many cases, you know exactly which plugins you may be drawing upon on a regular basis, and which classes they will refer to. In this case, extend the PluginClassLoader and define the map within the extending class. namespace My\\Plugins; use Zend\\Loader\\PluginClassLoader; class PluginLoader extends PluginClassLoader { /** * @var array Plugin map */ protected $plugins = [ 'foo' => 'My\\Plugins\\Foo', 'bar' => 'My\\Plugins\\Bar', 'foobar' => 'My\\Plugins\\FooBar', ]; } At this point, you can instantiate the map and immediately use it. $loader = new My\\Plugins\\PluginLoader(); $class = $loader->load('foobar'); // My\\Plugins\\FooBar PluginClassLoader makes use of late static binding, allowing per-class static maps. If you want to allow defining a static map specific to this extending class, declare a protected static $staticMap property: namespace My\\Plugins; use Zend\\Loader\\PluginClassLoader; class PluginLoader extends PluginClassLoader { protected static $staticMap = []; // ... } To inject the static map, call the addStaticMap() on the extension class: PluginLoader::addStaticMap([ 'baz' => 'My\\Plugins\\Baz', ]); Extending a plugin map using another plugin map In some cases, a general map class may already exist; as an example, several Zend Framework components defining plugin brokers have an associated PluginClassLoader extension defining the plugins available for that component within the framework. What if you want to define some additions to these? Where should that code go? One possibility is to define the map in a configuration file, and then inject the configuration into an instance of the plugin loader. Another solution is to define a new plugin map class. The class name or an instance of the class may then be passed to the constructor or registerPlugins() . namespace My\\Plugins; use Zend\\Loader\\PluginClassLoader; use Zend\\Http\\HeaderLoader; class PluginLoader extends PluginClassLoader { /** * @var array Plugin map */ protected $plugins = [ 'foo' => 'My\\Plugins\\Foo', 'bar' => 'My\\Plugins\\Bar', 'foobar' => 'My\\Plugins\\FooBar', ]; } // Inject in constructor: $loader = new HeaderLoader(PluginLoader::class); // as string class name $loader = new HeaderLoader(new PluginLoader()); // as instance // Or via registerPlugins(): $loader->registerPlugins(PluginLoader::class); // as string class name $loader->registerPlugins(new PluginLoader()); // as instance","title":"PluginClassLoader"},{"location":"plugin-class-loader/#the-pluginclassloader","text":"Resolving plugin names to class names is a common requirement within applications. The PluginClassLoader implements the interfaces PluginClassLocator , ShortNameLocator , and IteratorAggregate , providing a mechanism for aliasing plugin names to classnames for later retrieval. While it can act as a standalone class, it is intended that developers will extend the class to provide a per-component plugin map. This allows seeding the map with the most often-used plugins, while simultaneously allowing the end-user to overwrite existing or register new plugins. Additionally, PluginClassLoader provides the ability to statically seed all new instances of a given PluginClassLoader or one of its extensions (via Late Static Binding). If your application will always call for defining or overriding particular plugin maps on given PluginClassLoader extensions, this is a powerful capability.","title":"The PluginClassLoader"},{"location":"plugin-class-loader/#quick-start","text":"Typical use cases involve instantiating a PluginClassLoader , seeding it with one or more plugin/class name associations, and then using it to retrieve the class name associated with a given plugin name. use Zend\\Http\\HeaderLoader; // Provide a global map, or override defaults: HeaderLoader::addStaticMap([ 'xrequestedfor' => 'My\\Http\\Header\\XRequestedFor', ]); // Instantiate the loader: $loader = new Zend\\Http\\HeaderLoader(); // Register a new plugin: $loader->registerPlugin('xForwardedFor', 'My\\Http\\Header\\XForwardedFor'); // Load/retrieve the associated plugin class: $class = $loader->load('xrequestedfor'); // 'My\\Http\\Header\\XRequestedFor'","title":"Quick Start"},{"location":"plugin-class-loader/#configuration-options","text":"The constructor may take a single option, an array or Traversable object of key/value pairs corresponding to a plugin name and class name, respectively.","title":"Configuration Options"},{"location":"plugin-class-loader/#available-methods","text":"","title":"Available Methods"},{"location":"plugin-class-loader/#examples","text":"","title":"Examples"},{"location":"plugin-class-locator/","text":"The PluginClassLocator interface The PluginClassLocator interface describes a component capable of maintaining an internal map of plugin names to actual class names. Classes implementing this interface can register and unregister plugin/class associations, and return the entire map. Quick Start Classes implementing the PluginClassLocator must implement the following three methods: namespace Zend\\Loader; interface PluginClassLocator { public function registerPlugin($shortName, $className); public function unregisterPlugin($shortName); public function getRegisteredPlugins(); } Configuration Options This component defines no configuration options, as it is an interface. Available Methods registerPlugin registerPlugin(string $shortName, string $className) : void Implement this method to add or overwrite plugin name/class name associations in the internal plugin map. $shortName will be aliased to $className . unregisterPlugin unregisterPlugin(string $shortName) : void Implement this to allow removing an existing plugin mapping corresponding to $shortName . getRegisteredPlugins getRegisteredPlugins() : array Implement this to allow returning the plugin name/class name map.","title":"PluginClassLocator"},{"location":"plugin-class-locator/#the-pluginclasslocator-interface","text":"The PluginClassLocator interface describes a component capable of maintaining an internal map of plugin names to actual class names. Classes implementing this interface can register and unregister plugin/class associations, and return the entire map.","title":"The PluginClassLocator interface"},{"location":"plugin-class-locator/#quick-start","text":"Classes implementing the PluginClassLocator must implement the following three methods: namespace Zend\\Loader; interface PluginClassLocator { public function registerPlugin($shortName, $className); public function unregisterPlugin($shortName); public function getRegisteredPlugins(); }","title":"Quick Start"},{"location":"plugin-class-locator/#configuration-options","text":"This component defines no configuration options, as it is an interface.","title":"Configuration Options"},{"location":"plugin-class-locator/#available-methods","text":"","title":"Available Methods"},{"location":"short-name-locator/","text":"The ShortNameLocator Interface We often do not wish to refer to plugins by their fully qualified class name, but rather via a shorter, more memorable name: an alias. This also makes providing alternate implementations possible, as developers can register custom code under an existing alias. In the first case, consider the adapter pattern. It's often unwieldy to utilize a full class name (e.g., Zend\\Cloud\\DocumentService\\Adapter\\SimpleDb ); using the short name of the adapter, SimpleDb , would be much simpler. In the second case, consider the case of helpers. Let us assume we have a \"url\" helper; you may find that while the shipped helper does 90% of what you need, you'd like to extend it or provide an alternate implementation. At the same time, you don't want to change your code to reflect the new helper. In this case, a short name allows you to alias an alternate class to utilize. Classes implementing the ShortNameLocator interface provide a mechanism for resolving a short name to a fully qualified class name; how they do so is left to the implementers, and may combine strategies defined by other interfaces, such as PluginClassLocator . Quick Start Implementing a ShortNameLocator requires defining three methods, as shown below. namespace Zend\\Loader; interface ShortNameLocator { public function isLoaded($name); public function getClassName($name); public function load($name); } Configuration Options This component defines no configuration options, as it is an interface. Available Methods isLoaded isLoaded(string $name) : bool Implement this method to return a boolean indicating whether or not the class has been able to resolve the plugin name to a class. getClassName getClassName(string $name) : string Implement this method to return the class name associated with a plugin name. load load($name) : string|false This method should resolve a plugin name to a class name.","title":"ShortNameLocator"},{"location":"short-name-locator/#the-shortnamelocator-interface","text":"We often do not wish to refer to plugins by their fully qualified class name, but rather via a shorter, more memorable name: an alias. This also makes providing alternate implementations possible, as developers can register custom code under an existing alias. In the first case, consider the adapter pattern. It's often unwieldy to utilize a full class name (e.g., Zend\\Cloud\\DocumentService\\Adapter\\SimpleDb ); using the short name of the adapter, SimpleDb , would be much simpler. In the second case, consider the case of helpers. Let us assume we have a \"url\" helper; you may find that while the shipped helper does 90% of what you need, you'd like to extend it or provide an alternate implementation. At the same time, you don't want to change your code to reflect the new helper. In this case, a short name allows you to alias an alternate class to utilize. Classes implementing the ShortNameLocator interface provide a mechanism for resolving a short name to a fully qualified class name; how they do so is left to the implementers, and may combine strategies defined by other interfaces, such as PluginClassLocator .","title":"The ShortNameLocator Interface"},{"location":"short-name-locator/#quick-start","text":"Implementing a ShortNameLocator requires defining three methods, as shown below. namespace Zend\\Loader; interface ShortNameLocator { public function isLoaded($name); public function getClassName($name); public function load($name); }","title":"Quick Start"},{"location":"short-name-locator/#configuration-options","text":"This component defines no configuration options, as it is an interface.","title":"Configuration Options"},{"location":"short-name-locator/#available-methods","text":"","title":"Available Methods"},{"location":"spl-autoloader/","text":"The SplAutoloader Interface While any valid PHP callback may be registered with spl_autoload_register() , the autoloaders zend-loader provides offer more flexibility by being stateful and allowing configuration. To provide a common interface for such autoloaders, zend-loader provides the SplAutoloader interface. Objects implementing this interface provide a standard mechanism for configuration, a method that may be invoked to attempt to load a class, and a method for registering with the SPL autoloading mechanism. Quick Start To create your own autoloading mechanism, create a class implementing the SplAutoloader interface (you may review the methods defined in the methods section ). As an example, consider the following autoloader, which will look for a class file named after the class within a list of registered directories. namespace Custom; use InvalidArgumentException; use Traversable; use Zend\\Loader\\SplAutoloader; class ModifiedIncludePathAutoloader implements SplAutoloader { protected $paths = array(); public function __construct($options = null) { if (null !== $options) { $this->setOptions($options); } } public function setOptions($options) { if (! is_array($options) && ! $options instanceof Traversable) { throw new InvalidArgumentException(); } foreach ($options as $path) { if (! in_array($path, $this->paths)) { $this->paths[] = $path; } } } public function autoload($classname) { $filename = $classname . '.php'; foreach ($this->paths as $path) { $test = sprintf('%s/%s', $path, $filename); if (file_exists($test)) { return include($test); } } return false; } public function register() { spl_autoload_register([$this, 'autoload']); } } To use this ModifiedIncludePathAutoloader from the previous example: $options = [ '/path/one', '/path/two', ]; $autoloader = new Custom\\ModifiedIncludePathAutoloader($options); $autoloader->register(); Configuration Options This component defines no configuration options, as it is an interface. Available Methods __construct __construct($options = null) : void Autoloader constructors should optionally receive configuration. Typically, if received, these will be passed to the setOptions() method to process. setOptions setOptions(array|Traversable $options) : void Used to configure the autoloader. Typically, it should expect either an array or a Traversable object, though validation of the options is left to implementation. autoload autoload(string $class) : false|string This method should be used to resolve a class name to the file defining it. When a positive match is found, return the class name; otherwise, return a boolean false . register register() : void Should be used to register the autoloader instance with spl_autoload_register() . Invariably, the method should look like the following: public function register() { spl_autoload_register([$this, 'autoload']); }","title":"SplAutoloader"},{"location":"spl-autoloader/#the-splautoloader-interface","text":"While any valid PHP callback may be registered with spl_autoload_register() , the autoloaders zend-loader provides offer more flexibility by being stateful and allowing configuration. To provide a common interface for such autoloaders, zend-loader provides the SplAutoloader interface. Objects implementing this interface provide a standard mechanism for configuration, a method that may be invoked to attempt to load a class, and a method for registering with the SPL autoloading mechanism.","title":"The SplAutoloader Interface"},{"location":"spl-autoloader/#quick-start","text":"To create your own autoloading mechanism, create a class implementing the SplAutoloader interface (you may review the methods defined in the methods section ). As an example, consider the following autoloader, which will look for a class file named after the class within a list of registered directories. namespace Custom; use InvalidArgumentException; use Traversable; use Zend\\Loader\\SplAutoloader; class ModifiedIncludePathAutoloader implements SplAutoloader { protected $paths = array(); public function __construct($options = null) { if (null !== $options) { $this->setOptions($options); } } public function setOptions($options) { if (! is_array($options) && ! $options instanceof Traversable) { throw new InvalidArgumentException(); } foreach ($options as $path) { if (! in_array($path, $this->paths)) { $this->paths[] = $path; } } } public function autoload($classname) { $filename = $classname . '.php'; foreach ($this->paths as $path) { $test = sprintf('%s/%s', $path, $filename); if (file_exists($test)) { return include($test); } } return false; } public function register() { spl_autoload_register([$this, 'autoload']); } } To use this ModifiedIncludePathAutoloader from the previous example: $options = [ '/path/one', '/path/two', ]; $autoloader = new Custom\\ModifiedIncludePathAutoloader($options); $autoloader->register();","title":"Quick Start"},{"location":"spl-autoloader/#configuration-options","text":"This component defines no configuration options, as it is an interface.","title":"Configuration Options"},{"location":"spl-autoloader/#available-methods","text":"","title":"Available Methods"},{"location":"standard-autoloader/","text":"The StandardAutoloader Overview Zend\\Loader\\StandardAutoloader is designed as a PSR-0 -compliant autoloader. It assumes a 1:1 mapping of the namespace+classname to the filesystem, wherein namespace separators and underscores are translated to directory separators. The following statement illustrates how resolution works: $filename = str_replace( ['_', '\\\\'], DIRECTORY_SEPARATOR, $classname ) . '.php'; The StandardAutoloader requires that you explicitly register namespace/path pairs (or vendor prefix/path pairs), and will only load a file if it exists within the given path. Multiple pairs may be provided. As a measure of last resort, you may also use the StandardAutoloader as a \"fallback\" autoloader \u2014 one that will look for classes of any namespace or vendor prefix on the include_path . This practice is not recommended, however, due to performance implications. Finally, as with all autoloaders in zend-loader, the StandardAutoloader is capable of registering itself with PHP's SPL autoloader registry. Vocabulary: Namespaces vs. Vendor Prefixes In terms of autoloading, a \"namespace\" corresponds to PHP's own definition of namespaces. A \"vendor prefix\" refers to the practice, popularized in PHP versions prior to 5.3, of providing a pseudo-namespace in the form of underscore-separated words in class names. As an example, the class Phly_Couch_Document uses a vendor prefix of Phly , and a component prefix of Phly_Couch , but it is a class sitting in the global namespace. The StandardAutoloader is capable of loading either namespaced or vendor prefixed class names, but treats them separately when attempting to match them to an appropriate path. Quick Start Basic use of the StandardAutoloader requires registering namespace/path pairs. This can either be done at instantiation, or via explicit method calls after the object has been initialized. Calling register() will register the autoloader with the SPL autoloader registry. Manual Configuration use Zend\\Loader\\StandardAutoloader; // This example assumes the StandardAutoloader is autoloadable. $loader = new StandardAutoloader(); // Register the \"Phly\" namespace: $loader->registerNamespace('Phly', APPLICATION_PATH . '/../library/Phly'); // Register the \"Scapi\" vendor prefix: $loader->registerPrefix('Scapi', APPLICATION_PATH . '/../library/Scapi'); // Optionally, specify the autoloader as a \"fallback\" autoloader; // this is not recommended. $loader->setFallbackAutoloader(true); // Register with spl_autoload: $loader->register(); Configuration at Instantiation The StandardAutoloader may also be configured at instantiation. Please note: The argument passed may be either an array or a Traversable object. The argument passed should also be a valid argument for passing to the setOptions() method. The following is equivalent to the previous example. use Zend\\Loader\\StandardAutoloader; $loader = new StandardAutoloader([ 'namespaces' => [ 'Phly' => APPLICATION_PATH . '/../library/Phly', ], 'prefixes' => [ 'Scapi' => APPLICATION_PATH . '/../library/Scapi', ], 'fallback_autoloader' => true, ]); // Register with spl_autoload: $loader->register(); Configuration Options The StandardAutoloader defines the following options. namespaces An associative array of namespace/path pairs. The path should be an absolute path or path relative to the calling script, and contain only classes that live in that namespace (or its subnamespaces). prefixes An associative array of vendor prefix/path pairs. The path should be an absolute path or path relative to the calling script, and contain only classes that begin with the provided vendor prefix. fallback_autoloader A boolean value indicating whether or not this instance should act as a \"fallback\" autoloader (i.e., look for classes of any namespace or vendor prefix on the include_path ). By default, false . autoregister_zf is deprecated One other option is available to the StandardAutoloader : autoregister_zf . We do not document it any longer, as it is no longer relevant. Starting with the 2.5.0 release of Zend Framework, the framework package itself is a \"metapackage\", defining only a composer.json file listing the packages for each component. As such, there is no single path in which all ZF files live, making the autoregister_zf flag useless for versions starting with 2.5.0; it will only register the zend-loader path! If you are using this feature, you should update your code. We recommend using Composer 's autoloader for autoloading Zend Framework classes. Available Methods __construct __construct(array|Traversable $options = null) : void Create a new instance of the object. If $options is non-null, the argument is passed to setOptions() . setOptions setOptions(array|Traversable $options) : void Set object state based on provided options. Recognized keys are detailed under Configuration options , with the following behaviors: The namespaces value will be passed to registerNamespaces() . The prefixes value will be passed to registerPrefixes() . The fallback_autoloader value will be passed to setFallbackAutoloader() . setFallbackAutoloader setFallbackAutoloader(bool $flag) : void Takes a boolean flag indicating whether or not to act as a fallback autoloader when registered with the SPL autoloader. isFallbackAutoloader isFallbackAutoloader() : bool Indicates whether or not this instance is flagged as a fallback autoloader. registerNamespace registerNamespace(string $namespace, string $directory) : void Register a namespace with the autoloader, pointing it to a specific directory on the filesystem for class resolution. For classes matching that initial namespace, the autoloader will then perform lookups within that directory. registerNamespaces registerNamespaces(array|Traversable $namespaces) : void Register multiple namespaces with the autoloader, iterating through $namespaces and passing each key and item to registerNamespace() . registerPrefix registerPrefix(string $prefix, string $directory) : void Register a vendor prefix with the autoloader, pointing it to a specific directory on the filesystem for class resolution. For classes matching that initial vendor prefix, the autoloader will then perform lookups within that directory. registerPrefixes registerPrefixes(array|Traversable $prefixes) : void Register many vendor prefixes with the autoloader, traversing $prefixes and passing each key/value pair to registerPrefix() . autoload autoload(string $class) : false|string Attempts to load the class specified. Returns a boolean false on failure, or a string indicating the class loaded on success. register register() : void Registers the autoload() method of the current instance with spl_autoload_register() .","title":"StandardAutoloader"},{"location":"standard-autoloader/#the-standardautoloader","text":"","title":"The StandardAutoloader"},{"location":"standard-autoloader/#overview","text":"Zend\\Loader\\StandardAutoloader is designed as a PSR-0 -compliant autoloader. It assumes a 1:1 mapping of the namespace+classname to the filesystem, wherein namespace separators and underscores are translated to directory separators. The following statement illustrates how resolution works: $filename = str_replace( ['_', '\\\\'], DIRECTORY_SEPARATOR, $classname ) . '.php'; The StandardAutoloader requires that you explicitly register namespace/path pairs (or vendor prefix/path pairs), and will only load a file if it exists within the given path. Multiple pairs may be provided. As a measure of last resort, you may also use the StandardAutoloader as a \"fallback\" autoloader \u2014 one that will look for classes of any namespace or vendor prefix on the include_path . This practice is not recommended, however, due to performance implications. Finally, as with all autoloaders in zend-loader, the StandardAutoloader is capable of registering itself with PHP's SPL autoloader registry.","title":"Overview"},{"location":"standard-autoloader/#quick-start","text":"Basic use of the StandardAutoloader requires registering namespace/path pairs. This can either be done at instantiation, or via explicit method calls after the object has been initialized. Calling register() will register the autoloader with the SPL autoloader registry.","title":"Quick Start"},{"location":"standard-autoloader/#configuration-options","text":"The StandardAutoloader defines the following options.","title":"Configuration Options"},{"location":"standard-autoloader/#available-methods","text":"","title":"Available Methods"}]}